<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Pok√©mon-like Game</title>
    <style>
        * { margin: 0; padding: 0; }
        body {
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
        }
        #renderCanvas {
            width: 100%;
            height: 100vh;
            display: block;
        }
        #instructions {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.8;
            z-index: 1000;
            pointer-events: none;
        }
        #instructions strong { color: #FFD700; }

        /* ========= OVERLAY / BLUR POUR MENUS (PAS POUR COMBAT) ========= */
        #menuOverlay {
            position: fixed;
            inset: 0;
            background: rgba(0,0,0,0.5);
            backdrop-filter: blur(4px);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease;
            z-index: 900;
        }
        #menuOverlay.visible {
            opacity: 1;
            pointer-events: auto;
        }

        /* ========= FEN√äTRES DE MENU ========= */
        .menu-window {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            width: 420px;
            max-width: 90%;
            background: radial-gradient(circle at top, #1a3b7a, #051024);
            border: 3px solid #FFD700;
            border-radius: 18px;
            padding: 18px 20px;
            color: white;
            box-shadow: 0 10px 26px rgba(0,0,0,0.6);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.2s ease, transform 0.2s ease;
            z-index: 1000;
        }
        .menu-window.open {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }

        .menu-title {
            font-size: 24px;
            color: #FFD700;
            text-align: center;
            margin-bottom: 10px;
            text-shadow: 0 0 4px black;
        }
        .menu-subtitle {
            font-size: 13px;
            text-align: center;
            color: #d0d8ff;
            margin-bottom: 10px;
        }

        .menu-buttons {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 6px;
        }
        .menu-btn {
            padding: 10px 14px;
            border-radius: 10px;
            border: none;
            background: linear-gradient(90deg, #1b4d9a, #153a74);
            color: white;
            font-size: 15px;
            text-align: left;
            cursor: pointer;
            box-shadow: 0 3px 6px rgba(0,0,0,0.5);
            transition: transform 0.08s ease, box-shadow 0.08s ease, background 0.15s ease;
        }
        .menu-btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.6);
            background: linear-gradient(90deg, #2464c4, #184386);
        }

        .menu-btn.danger {
            background: linear-gradient(90deg, #8d1c1c, #5c1010);
        }
        .menu-btn.danger:hover {
            background: linear-gradient(90deg, #b12525, #6d1515);
        }

        /* ========= INVENTAIRE ========= */
        #inventoryMenu {
            width: 600px;
            max-width: 95%;
        }
        #inventoryGrid {
            display: grid;
            grid-template-columns: repeat(4, minmax(0, 1fr));
            gap: 10px;
            margin: 10px 0 8px;
        }
        .inv-item {
            background: rgba(15, 40, 90, 0.95);
            border-radius: 12px;
            padding: 8px 6px;
            text-align: center;
            border: 2px solid rgba(0,255,255,0.4);
            cursor: pointer;
            transition: transform 0.1s ease, box-shadow 0.1s ease, border-color 0.1s ease;
            box-shadow: 0 3px 6px rgba(0,0,0,0.5);
        }
        .inv-item:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 10px rgba(0,0,0,0.7);
            border-color: rgba(255,255,0,0.8);
        }
        .inv-icon {
            font-size: 24px;
            margin-bottom: 2px;
        }
        .inv-name {
            font-size: 12px;
        }
        .inv-count {
            font-size: 13px;
            color: #ffe780;
        }

        #inventoryDetail {
            margin-top: 6px;
            padding: 8px;
            border-radius: 12px;
            background: rgba(0,0,0,0.45);
            border: 1px solid rgba(255,255,255,0.1);
            display: none;
        }
        #inventoryDetail.show {
            display: block;
        }
        #inventoryDetailTitle {
            font-size: 16px;
            color: #FFD700;
            margin-bottom: 4px;
        }
        #inventoryDetailDesc {
            font-size: 13px;
            margin-bottom: 6px;
        }
        .detail-buttons {
            display: flex;
            gap: 8px;
            justify-content: flex-end;
        }
        .detail-btn {
            padding: 6px 10px;
            font-size: 13px;
            border-radius: 8px;
            border: none;
            cursor: pointer;
            background: #1b4d9a;
            color: white;
        }
        .detail-btn.secondary {
            background: #555;
        }

        .menu-footer {
            margin-top: 8px;
            text-align: right;
            font-size: 12px;
            color: #aeb8ff;
        }

        /* ========= √âQUIPE ========= */
        #teamMenu {
            width: 520px;
            max-width: 95%;
        }
        #teamList {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-top: 10px;
        }
        .team-card {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 8px 10px;
            border-radius: 12px;
            background: rgba(10, 35, 80, 0.95);
            border: 2px solid rgba(255,215,0,0.4);
            box-shadow: 0 3px 7px rgba(0,0,0,0.6);
        }
        .team-icon {
            font-size: 28px;
        }
        .team-main {
            flex: 1;
        }
        .team-name {
            font-size: 15px;
        }
        .team-level {
            font-size: 12px;
            color: #d0d8ff;
        }
        .team-hpbar-wrap {
            margin-top: 4px;
            background: #222;
            border-radius: 6px;
            overflow: hidden;
            height: 8px;
        }
        .team-hpbar {
            height: 100%;
            background: linear-gradient(90deg, #28c728, #8be628);
        }
        .team-extra {
            font-size: 12px;
            text-align: right;
            color: #ffdede;
        }

        /* ========= DIALOGUE ========= */
        #dialogBox {
            position: fixed;
            left: 50%;
            bottom: 20px;
            transform: translateX(-50%);
            width: 80%;
            max-width: 700px;
            background: rgba(0,0,0,0.9);
            border-radius: 12px;
            border: 2px solid white;
            color: white;
            padding: 10px 14px;
            font-size: 15px;
            line-height: 1.4;
            box-shadow: 0 6px 15px rgba(0,0,0,0.7);
            display: none;
            z-index: 1200;
        }
        #dialogBox.show {
            display: block;
        }

        /* ========= PETIT HUD ========= */
        #hudSpeed {
            position: fixed;
            right: 15px;
            bottom: 15px;
            padding: 6px 10px;
            font-size: 13px;
            border-radius: 12px;
            background: rgba(0,0,0,0.7);
            color: white;
            z-index: 1100;
        }
        #hudSpeed span {
            font-weight: bold;
        }

        /* ========= UI COMBAT STYLE POK√âMON ========= */

        /* Top : infos des deux combattants */
        #combatTopUI {
            position: fixed;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            width: 80%;
            max-width: 900px;
            display: none;
            justify-content: space-between;
            z-index: 950;
            pointer-events: none;
        }
        .combat-mon-card {
            background: #f8f8f8;
            border: 3px solid #000;
            border-radius: 10px;
            padding: 6px 10px;
            min-width: 36%;
            box-shadow: 0 3px 6px rgba(0,0,0,0.5);
            font-size: 13px;
        }
        .combat-mon-name {
            font-weight: bold;
            font-size: 14px;
            margin-bottom: 2px;
        }
        .combat-mon-hpbar-wrap {
            margin-top: 3px;
            background: #ccc;
            border-radius: 5px;
            overflow: hidden;
            height: 8px;
        }
        .combat-mon-hpbar {
            height: 100%;
            background: linear-gradient(90deg,#28c728,#8be628);
        }
        .combat-mon-hp-text {
            font-size: 12px;
            margin-top: 2px;
        }

        /* Bas : panneau Pok√©mon GBA */
        #combatUI {
            position: fixed;
            left: 50%;
            transform: translateX(-50%);
            bottom: 0;
            width: 90%;
            max-width: 900px;
            height: 170px;
            background: #f0f0ff;
            border-top: 3px solid #000;
            border-left: 3px solid #000;
            border-right: 3px solid #000;
            box-shadow: 0 -4px 10px rgba(0,0,0,0.7);
            display: none;
            z-index: 950;
            font-size: 14px;
        }
        #combatInner {
            display: grid;
            grid-template-columns: 2fr 2fr;
            grid-template-rows: auto 1fr;
            height: 100%;
        }
        #combatQuestionBox {
            grid-column: 1 / 3;
            border-bottom: 2px solid #000;
            padding: 6px 10px;
            background: #ffffff;
        }
        #combatQuestionText {
            font-weight: bold;
        }

        #combatChoices {
            border-right: 2px solid #000;
            padding: 8px 10px;
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 4px;
        }
        .combat-choice-btn {
            border: 2px solid #000;
            background: #d0d8ff;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            text-align: left;
            padding: 4px 6px;
        }
        .combat-choice-btn.selected {
            background: #ffe080;
            outline: 2px solid #000;
        }

        #combatLogBox {
            padding: 6px 10px;
            background: #ffffff;
            border-left: 2px solid #000;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #combatLogText {
            white-space: pre-line;
            font-size: 13px;
        }
        #combatTurn {
            font-size: 12px;
            text-align: right;
            color: #333;
        }

        /* Sous-menu attaques */
        #combatAttackList {
            position: absolute;
            left: 0;
            top: 0;
            right: 50%;
            bottom: 0;
            padding: 8px 10px;
            background: #f0f0ff;
            border-right: 2px solid #000;
            display: none;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 4px;
        }
        .combat-attack-btn {
            border: 2px solid #000;
            background: #e0e8ff;
            border-radius: 4px;
            font-size: 13px;
            cursor: pointer;
            text-align: left;
            padding: 4px 6px;
        }
        .combat-attack-btn.selected {
            background: #ffe080;
            outline: 2px solid #000;
        }
        #combatAttackInfo {
            position: absolute;
            left: 50%;
            top: 32px;
            right: 0;
            bottom: 0;
            padding: 4px 6px;
            font-size: 12px;
            border-left: 2px solid #000;
            background: #ffffff;
            display: none;
        }
    </style>
</head>
<body>
<canvas id="renderCanvas"></canvas>

<div id="instructions">
    <strong>üéÆ Contr√¥les:</strong><br>
    ZQSD : D√©placer<br>
    Shift : Courir<br>
    E : Interagir / Parler / Combat<br>
    M : Menu<br><br>
    <strong>Manette:</strong><br>
    A : Courir / Valider | B : Interagir | Y : Menu
</div>

<!-- Overlay flout√© (menus / dialogues, pas combat) -->
<div id="menuOverlay"></div>

<!-- MENU PRINCIPAL -->
<div id="mainMenu" class="menu-window">
    <div class="menu-title">‚öîÔ∏è MENU ‚öîÔ∏è</div>
    <div class="menu-subtitle">Dresseur: <span id="trainerName">Red</span> ‚Äî <span id="trainerMoney">500‚ÇΩ</span></div>
    <div class="menu-buttons">
        <button class="menu-btn" id="btnMenuInventory">üì¶ Inventaire</button>
        <button class="menu-btn" id="btnMenuTeam">üë• √âquipe</button>
        <button class="menu-btn" id="btnMenuMap">üó∫Ô∏è Carte</button>
        <button class="menu-btn" id="btnMenuSave">üíæ Sauvegarder</button>
        <button class="menu-btn" id="btnMenuOptions">‚öôÔ∏è Options</button>
        <button class="menu-btn danger" id="btnMenuClose">‚ùå Fermer</button>
    </div>
</div>

<!-- MENU INVENTAIRE -->
<div id="inventoryMenu" class="menu-window">
    <div class="menu-title">üì¶ INVENTAIRE</div>
    <div class="menu-subtitle">S√©lectionne un objet pour voir les options.</div>

    <div id="inventoryGrid"></div>

    <div id="inventoryDetail">
        <div id="inventoryDetailTitle"></div>
        <div id="inventoryDetailDesc"></div>
        <div class="detail-buttons">
            <button class="detail-btn" id="btnUseItem">Utiliser</button>
            <button class="detail-btn" id="btnInfoItem">Infos</button>
            <button class="detail-btn secondary" id="btnBackItem">Retour</button>
        </div>
    </div>

    <div class="menu-footer">
        <button class="detail-btn secondary" id="btnInventoryBack">‚¨Ö Retour au menu</button>
    </div>
</div>

<!-- MENU √âQUIPE -->
<div id="teamMenu" class="menu-window">
    <div class="menu-title">üë• √âQUIPE</div>
    <div class="menu-subtitle">Tes Pok√©mon actuels.</div>

    <div id="teamList"></div>

    <div class="menu-footer">
        <button class="detail-btn secondary" id="btnTeamBack">‚¨Ö Retour au menu</button>
    </div>
</div>

<!-- DIALOGUE -->
<div id="dialogBox"><span id="dialogText"></span></div>

<!-- HUD VITESSE -->
<div id="hudSpeed">Vitesse : <span id="hudSpeedText">üö∂ Marche</span></div>

<!-- ===== COMBAT TOP UI (INFO POK√âMON) ===== -->
<div id="combatTopUI">
    <div class="combat-mon-card" id="combatPlayerCard">
        <div class="combat-mon-name" id="combatPlayerNameTop">Pikachu N.12</div>
        <div class="combat-mon-hpbar-wrap">
            <div class="combat-mon-hpbar" id="combatPlayerHpBar" style="width:100%;"></div>
        </div>
        <div class="combat-mon-hp-text" id="combatPlayerHpText">35 / 35 PV</div>
    </div>
    <div class="combat-mon-card" id="combatEnemyCard">
        <div class="combat-mon-name" id="combatEnemyNameTop">Rattata N.8</div>
        <div class="combat-mon-hpbar-wrap">
            <div class="combat-mon-hpbar" id="combatEnemyHpBar" style="width:100%;"></div>
        </div>
        <div class="combat-mon-hp-text" id="combatEnemyHpText">30 / 30 PV</div>
    </div>
</div>

<!-- ===== COMBAT BOTTOM UI ===== -->
<div id="combatUI">
    <div id="combatInner">
        <div id="combatQuestionBox">
            <span id="combatQuestionText">Que doit faire Pikachu ?</span>
        </div>

        <!-- Choix principaux -->
        <div id="combatChoices">
            <button class="combat-choice-btn" id="combatChoiceAttack" data-action="attack">Attaquer</button>
            <button class="combat-choice-btn" id="combatChoiceBag" data-action="bag">Sac</button>
            <button class="combat-choice-btn" id="combatChoiceRun" data-action="run">Fuite</button>
            <!-- 4√®me case vide pour le layout -->
            <div></div>
        </div>

        <!-- Zone log -->
        <div id="combatLogBox">
            <div id="combatLogText">Un combat commence !</div>
            <div id="combatTurn">Tour 1</div>
        </div>

        <!-- Sous-menu Attaques -->
        <div id="combatAttackList">
            <button class="combat-attack-btn" id="attackBtn0" data-index="0">-</button>
            <button class="combat-attack-btn" id="attackBtn1" data-index="1">-</button>
            <button class="combat-attack-btn" id="attackBtn2" data-index="2">-</button>
            <button class="combat-attack-btn" id="attackBtn3" data-index="3">-</button>
        </div>
        <div id="combatAttackInfo">
            <div id="combatAttackInfoText">Infos attaque...</div>
        </div>
    </div>
</div>

<script src="https://cdn.babylonjs.com/babylon.js?v=6.40"></script>

<script>
console.log("üéÆ D√©marrage du jeu...");

const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true, { preserveDrawingBuffer: true, stencil: true });

let gamepad = null;

const gameState = {
    mode: "exploration", // "exploration" | "combat"
    menuOpen: false,
    dialogOpen: false,
    isRunning: false,
    interactionRange: 3,
    playerInventory: [
        {name: "Potion", count: 3, icon: "üß™", description: "Restaure un peu de PV (20 PV)."},
        {name: "Pok√© Ball", count: 5, icon: "‚ö™", description: "Permet de capturer des Pok√©mon."},
        {name: "Antidote", count: 1, icon: "üíä", description: "Soigne l‚Äôempoisonnement."}
    ],
    team: [
        {
            name: "Pikachu",
            level: 12,
            hp: 30,
            maxHp: 35,
            icon: "‚ö°",
            status: "OK",
            attacks: [
                { name: "Charge",    power: 10, accuracy: 100 },
                { name: "√âclair",    power: 18, accuracy: 95 },
                { name: "Rugissement", power: 0,  accuracy: 100, effect: "atk_down" }
            ]
        },
        {name: "Salam√®che", level: 10, hp: 28, maxHp: 30, icon: "üî•", status: "OK"},
        {name: "Carapuce", level: 9,  hp: 22, maxHp: 28, icon: "üíß", status: "OK"}
    ],
    playerName: "Red",
    money: 500,
    selectedItemIndex: null
};

// ====== R√âF√âRENCES DOM ======
const overlayEl = document.getElementById("menuOverlay");
const mainMenuEl = document.getElementById("mainMenu");
const inventoryMenuEl = document.getElementById("inventoryMenu");
const teamMenuEl = document.getElementById("teamMenu");
const dialogBoxEl = document.getElementById("dialogBox");
const dialogTextEl = document.getElementById("dialogText");
const hudSpeedTextEl = document.getElementById("hudSpeedText");

const trainerNameEl = document.getElementById("trainerName");
const trainerMoneyEl = document.getElementById("trainerMoney");

// Combat DOM
const combatTopUIEl          = document.getElementById("combatTopUI");
const combatPlayerNameTopEl  = document.getElementById("combatPlayerNameTop");
const combatEnemyNameTopEl   = document.getElementById("combatEnemyNameTop");
const combatPlayerHpBarEl    = document.getElementById("combatPlayerHpBar");
const combatEnemyHpBarEl     = document.getElementById("combatEnemyHpBar");
const combatPlayerHpTextEl   = document.getElementById("combatPlayerHpText");
const combatEnemyHpTextEl    = document.getElementById("combatEnemyHpText");

const combatUIEl             = document.getElementById("combatUI");
const combatQuestionTextEl   = document.getElementById("combatQuestionText");
const combatLogTextEl        = document.getElementById("combatLogText");
const combatTurnEl           = document.getElementById("combatTurn");

const combatChoiceAttackEl   = document.getElementById("combatChoiceAttack");
const combatChoiceBagEl      = document.getElementById("combatChoiceBag");
const combatChoiceRunEl      = document.getElementById("combatChoiceRun");
const combatChoicesButtons   = [combatChoiceAttackEl, combatChoiceBagEl, combatChoiceRunEl];

const combatAttackListEl     = document.getElementById("combatAttackList");
const combatAttackInfoEl     = document.getElementById("combatAttackInfo");
const combatAttackInfoTextEl = document.getElementById("combatAttackInfoText");
const attackButtons          = [
    document.getElementById("attackBtn0"),
    document.getElementById("attackBtn1"),
    document.getElementById("attackBtn2"),
    document.getElementById("attackBtn3")
];

// Boutons menu principal
const btnMenuInventory = document.getElementById("btnMenuInventory");
const btnMenuTeam = document.getElementById("btnMenuTeam");
const btnMenuMap = document.getElementById("btnMenuMap");
const btnMenuSave = document.getElementById("btnMenuSave");
const btnMenuOptions = document.getElementById("btnMenuOptions");
const btnMenuClose = document.getElementById("btnMenuClose");

// Inventaire DOM
const inventoryGridEl = document.getElementById("inventoryGrid");
const inventoryDetailEl = document.getElementById("inventoryDetail");
const inventoryDetailTitleEl = document.getElementById("inventoryDetailTitle");
const inventoryDetailDescEl = document.getElementById("inventoryDetailDesc");
const btnUseItemEl = document.getElementById("btnUseItem");
const btnInfoItemEl = document.getElementById("btnInfoItem");
const btnBackItemEl = document.getElementById("btnBackItem");
const btnInventoryBackEl = document.getElementById("btnInventoryBack");

// √âquipe DOM
const teamListEl = document.getElementById("teamList");
const btnTeamBackEl = document.getElementById("btnTeamBack");

// ===== DIALOGUE GLOBAL (hors combat) =====
function showDialog(text) {
    if (gameState.mode === "combat") {
        // En combat, on utilise la zone de log d√©di√©e
        combatLogTextEl.textContent = text;
        return;
    }
    console.log("üí¨", text);
    dialogTextEl.textContent = text;
    dialogBoxEl.classList.add("show");
    gameState.dialogOpen = true;
    overlayEl.classList.add("visible");

    setTimeout(() => {
        dialogBoxEl.classList.remove("show");
        gameState.dialogOpen = false;
        if (!gameState.menuOpen) {
            overlayEl.classList.remove("visible");
        }
    }, 2800);
}

/*****************************************************
 * M√âCANIQUE DE COMBAT SIMPLE (FORMAT B)
 *****************************************************/
const combatState = {
    active: false,
    turn: 1,
    phase: "root", // "root" | "attacks"
    rootIndex: 0,
    attackIndex: 0
};

const combat = {
    player: {
        name: "Pikachu",
        level: 12,
        maxHp: 35,
        hp: 35,
        attack: 12,
        defense: 6,
        speed: 10,
        attacks: [
            { name: "Charge",     power: 10, accuracy: 100 },
            { name: "√âclair",     power: 18, accuracy: 95 },
            { name: "Rugissement", power: 0,  accuracy: 100, effect: "atk_down" }
        ]
    },
    enemy: {
        name: "Rattata sauvage",
        level: 8,
        maxHp: 30,
        hp: 30,
        attack: 9,
        defense: 4,
        speed: 7,
        attacks: [
            { name: "Charge", power: 8, accuracy: 100 },
            { name: "Mimi-Queue", power: 0, accuracy: 100, effect: "def_down" }
        ]
    }
};

function computeDamage(attacker, defender, move) {
    if (!move || move.power === 0) return 0;
    const base = attacker.attack + move.power - defender.defense;
    const variance = 0.85 + Math.random() * 0.3; // 0.85 - 1.15
    let dmg = Math.floor(Math.max(1, base) * variance);
    return dmg;
}

function hpBarColor(pct) {
    if (pct > 0.5) return "linear-gradient(90deg,#28c728,#8be628)";
    if (pct > 0.2) return "linear-gradient(90deg,#e6c228,#f6e46b)";
    return "linear-gradient(90deg,#e62828,#f66b6b)";
}

function updateCombatTopUI() {
    const p = combat.player;
    const e = combat.enemy;

    const pPct = p.hp / p.maxHp;
    const ePct = e.hp / e.maxHp;

    combatPlayerNameTopEl.textContent = `${p.name} N.${p.level}`;
    combatEnemyNameTopEl.textContent  = `${e.name} N.${e.level}`;

    combatPlayerHpBarEl.style.width   = (pPct * 100) + "%";
    combatPlayerHpBarEl.style.background = hpBarColor(pPct);
    combatPlayerHpTextEl.textContent  = `${p.hp} / ${p.maxHp} PV`;

    combatEnemyHpBarEl.style.width    = (ePct * 100) + "%";
    combatEnemyHpBarEl.style.background = hpBarColor(ePct);
    combatEnemyHpTextEl.textContent   = `${e.hp} / ${e.maxHp} PV`;
}

function setCombatQuestion(text) {
    combatQuestionTextEl.textContent = text;
}

function setCombatLog(text) {
    combatLogTextEl.textContent = text;
}

function setCombatTurnLabel() {
    combatTurnEl.textContent = `Tour ${combatState.turn}`;
}

function enemyChooseMove() {
    const moves = combat.enemy.attacks;
    return moves[Math.floor(Math.random() * moves.length)];
}

// Un tour complet : joueur puis ennemi (si vivant)
function doCombatRound(playerAction) {
    const p = combat.player;
    const e = combat.enemy;
    let log = `Tour ${combatState.turn}\n`;

    // Joueur agit d'abord (simple pour l‚Äôinstant)
    if (playerAction.type === "attack") {
        const move = p.attacks[playerAction.index];
        if (!move) {
            log += `${p.name} h√©site...\n`;
        } else {
            // pr√©cision
            if (Math.random()*100 <= move.accuracy) {
                const dmg = computeDamage(p, e, move);
                e.hp = Math.max(0, e.hp - dmg);
                log += `${p.name} utilise ${move.name} !\n`;
                if (dmg > 0) log += `${e.name} perd ${dmg} PV.\n`;
            } else {
                log += `${p.name} rate son attaque ${move.name} !\n`;
            }
        }
    } else if (playerAction.type === "bag") {
        // Sac : tenter d'utiliser une potion sur le joueur
        const potion = gameState.playerInventory.find(it => it.name.toLowerCase().includes("potion") && it.count > 0);
        if (potion) {
            const healAmount = potion.name.toLowerCase().includes("hyper") ? 50 : 20;
            const before = p.hp;
            p.hp = Math.min(p.maxHp, p.hp + healAmount);
            const healed = p.hp - before;
            potion.count--;
            log += `${gameState.playerName} utilise ${potion.name} sur ${p.name} !\n`;
            log += `${p.name} r√©cup√®re ${healed} PV.\n`;
        } else {
            log += `Le sac est vide... Aucun objet utilisable !\n`;
        }
    } else if (playerAction.type === "run") {
        log += `${gameState.playerName} prend la fuite !\n`;
        combatState.active = false;
        return { log, finished: true, escaped: true };
    }

    // L'ennemi est-il K.O. ?
    if (e.hp <= 0) {
        log += `${e.name} est K.O !\n`;
        combatState.active = false;
        return { log, finished: true, escaped: false };
    }

    // Ennemi agit
    const enemyMove = enemyChooseMove();
    if (enemyMove) {
        if (Math.random()*100 <= enemyMove.accuracy) {
            const dmg = computeDamage(e, p, enemyMove);
            p.hp = Math.max(0, p.hp - dmg);
            log += `${e.name} utilise ${enemyMove.name} !\n`;
            if (dmg > 0) log += `${p.name} perd ${dmg} PV.\n`;
        } else {
            log += `${e.name} rate son attaque ${enemyMove.name} !\n`;
        }
    }

    if (p.hp <= 0) {
        log += `${p.name} est K.O !\n`;
        combatState.active = false;
        return { log, finished: true, escaped: false };
    }

    combatState.turn++;
    return { log, finished: false, escaped: false };
}

// ====== COMBAT UI CONTROL ======
function enterCombatFromWorld(playerCollider, npc, camera, combatContext) {
    console.log("‚öîÔ∏è Entr√©e en combat");
    // Sync avec premier monstre de l'√©quipe
    const lead = gameState.team[0];
    if (lead) {
        combat.player.name   = lead.name;
        combat.player.level  = lead.level || 5;
        combat.player.maxHp  = lead.maxHp;
        combat.player.hp     = lead.hp;
        combat.player.attacks = lead.attacks || combat.player.attacks;
    } else {
        combat.player.hp = combat.player.maxHp;
    }

    // Reset ennemi
    combat.enemy.hp = combat.enemy.maxHp;

    combatState.active = true;
    combatState.turn   = 1;
    combatState.phase  = "root";
    combatState.rootIndex = 0;
    combatState.attackIndex = 0;

    gameState.mode = "combat";
    gameState.menuOpen = false;

    // Sauvegarde de la cam√©ra & positions
    combatContext.prevPlayerPos = playerCollider.position.clone();
    combatContext.prevNpcPos    = npc.position.clone();
    combatContext.prevRadius    = camera.radius;
    combatContext.prevHeight    = camera.heightOffset;
    combatContext.prevRot       = camera.rotationOffset;

    // Position "ar√®ne"
    playerCollider.position = new BABYLON.Vector3(-3,0.5,0);
    npc.position            = new BABYLON.Vector3(3,0.9,0);

    camera.radius        = 10;
    camera.heightOffset  = 8;
    camera.rotationOffset = 0;

    // Afficher UI combat
    combatTopUIEl.style.display = "flex";
    combatUIEl.style.display    = "block";
    // Pas d'overlay/blur
    overlayEl.classList.remove("visible");
    dialogBoxEl.classList.remove("show");
    gameState.dialogOpen = false;

    updateCombatTopUI();
    setCombatQuestion(`Que doit faire ${combat.player.name} ?`);
    setCombatLog("Un combat commence !");
    setCombatTurnLabel();
    updateCombatRootSelection();
    hideAttackMenu();
}

function exitCombatToWorld(playerCollider, npc, camera, combatContext) {
    console.log("üèÅ Fin de combat / retour exploration");
    combatTopUIEl.style.display = "none";
    combatUIEl.style.display    = "none";
    gameState.mode = "exploration";

    // Sauvegarder PV du lead dans l'√©quipe
    const lead = gameState.team[0];
    if (lead) {
        lead.hp = combat.player.hp;
    }

    // Restaurer cam√©ra & positions
    if (combatContext.prevPlayerPos) playerCollider.position = combatContext.prevPlayerPos;
    if (combatContext.prevNpcPos)    npc.position = combatContext.prevNpcPos;
    camera.radius        = combatContext.prevRadius;
    camera.heightOffset  = combatContext.prevHeight;
    camera.rotationOffset = combatContext.prevRot;

    if (!gameState.menuOpen && !gameState.dialogOpen) {
        overlayEl.classList.remove("visible");
    }
}

function updateCombatRootSelection() {
    combatChoicesButtons.forEach((btn, idx) => {
        btn.classList.toggle("selected", idx === combatState.rootIndex);
    });
}

function showAttackMenu() {
    combatState.phase = "attacks";
    combatAttackListEl.style.display = "grid";
    combatAttackInfoEl.style.display = "block";

    // Remplir les 4 boutons
    const moves = combat.player.attacks || [];
    for (let i = 0; i < 4; i++) {
        const btn = attackButtons[i];
        const move = moves[i];
        if (move) {
            btn.textContent = move.name;
            btn.disabled = false;
        } else {
            btn.textContent = "-";
            btn.disabled = true;
        }
        btn.classList.remove("selected");
    }
    combatState.attackIndex = 0;
    updateAttackSelection();
    updateAttackInfo();
}

function hideAttackMenu() {
    combatState.phase = "root";
    combatAttackListEl.style.display  = "none";
    combatAttackInfoEl.style.display  = "none";
}

function updateAttackSelection() {
    attackButtons.forEach((btn, i) => {
        btn.classList.toggle("selected", i === combatState.attackIndex);
    });
}

function updateAttackInfo() {
    const moves = combat.player.attacks || [];
    const move = moves[combatState.attackIndex];
    if (!move) {
        combatAttackInfoTextEl.textContent = "Pas d'attaque.";
    } else {
        let txt = `${move.name}\nPuissance: ${move.power}\nPr√©cision: ${move.accuracy}%`;
        if (move.effect) {
            txt += `\nEffet: ${move.effect}`;
        }
        combatAttackInfoTextEl.textContent = txt;
    }
}

function handlePlayerRootChoice(action) {
    if (!combatState.active) return;

    if (action === "attack") {
        showAttackMenu();
        setCombatQuestion("Choisis une attaque :");
        return;
    }

    if (action === "bag") {
        const result = doCombatRound({type:"bag"});
        updateCombatTopUI();
        setCombatLog(result.log);
        setCombatTurnLabel();
        if (result.finished) {
            // Fin de combat (K.O. ou fuite ? ici seulement K.O. joueur ou ennemi)
            // On laisse un petit d√©lai virtuel avant retour
            setTimeout(() => {
                // g√©r√© dans la sc√®ne apr√®s
            }, 0);
        }
        return result;
    }

    if (action === "run") {
        const result = doCombatRound({type:"run"});
        updateCombatTopUI();
        setCombatLog(result.log);
        setCombatTurnLabel();
        return result;
    }
}

function handlePlayerAttackChoice(index) {
    const moves = combat.player.attacks || [];
    const move = moves[index];
    if (!move) return;
    const result = doCombatRound({type:"attack", index});
    updateCombatTopUI();
    setCombatLog(result.log);
    setCombatTurnLabel();
    return result;
}

// ========== BABYLON SCENE ==========
function createScene() {
    const scene = new BABYLON.Scene(engine);
    scene.collisionsEnabled = true;

    console.log("üåç Cr√©ation de la sc√®ne...");

    // Lumi√®re
    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);
    light.intensity = 1.2;

    // Sol
    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width:50, height:50}, scene);
    const groundMat = new BABYLON.StandardMaterial("gm", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.3, 0.7, 0.3);
    ground.material = groundMat;
    ground.checkCollisions = true;

    // Player collider
    const playerCollider = BABYLON.MeshBuilder.CreateBox("pc", {width:1, height:1, depth:1}, scene);
    playerCollider.position = new BABYLON.Vector3(0,0.5,0);
    playerCollider.isVisible = false;
    playerCollider.checkCollisions = true;
    playerCollider.ellipsoid = new BABYLON.Vector3(0.5,0.5,0.5);
    playerCollider.ellipsoidOffset = new BABYLON.Vector3(0,0.5,0);

    // Player mesh
    const player = BABYLON.MeshBuilder.CreateSphere("player",{diameter:1},scene);
    const pmat = new BABYLON.PBRMaterial("pmat", scene);
    pmat.albedoColor = new BABYLON.Color3(1,0.4,0);
    player.material = pmat;
    player.parent = playerCollider;

    // PNJ
    const npc = BABYLON.MeshBuilder.CreateBox("npc", {
        height: 1.8,
        width: 0.8,
        depth: 0.8
    }, scene);
    npc.position = new BABYLON.Vector3(5, 0.9, 5);
    npc.material = new BABYLON.StandardMaterial("npcMat", scene);
    npc.material.diffuseColor = new BABYLON.Color3(0, 0, 1);
    npc.checkCollisions = true;

    // Ic√¥ne PNG au-dessus du PNJ
    const npcIcon = BABYLON.MeshBuilder.CreatePlane("npcIcon", {
        width: 0.7,
        height: 1.2
    }, scene);
    npcIcon.position = npc.position.add(new BABYLON.Vector3(0, 1.9, 0));
    npcIcon.billboardMode = BABYLON.Mesh.BILLBOARDMODE_ALL;

    const npcIconMat = new BABYLON.StandardMaterial("npcIconMat", scene);
    npcIconMat.diffuseTexture = new BABYLON.Texture("Assets/icons/Point-exclamation.png", scene);
    npcIconMat.diffuseTexture.hasAlpha = true;
    npcIconMat.backFaceCulling = false;
    npcIconMat.emissiveColor = new BABYLON.Color3(1,1,1);
    npcIcon.material = npcIconMat;
    npcIcon.isVisible = false;

    // Item au sol
    const item = BABYLON.MeshBuilder.CreateSphere("item",{diameter:0.6},scene);
    item.position = new BABYLON.Vector3(-5,0.4,-3);
    item.material = new BABYLON.StandardMaterial("itemMat",scene);
    item.material.emissiveColor = new BABYLON.Color3(1,0.7,0);

    // Murs
    function wall(x,z,w,h,d) {
        const box = BABYLON.MeshBuilder.CreateBox("wall",{width:w,height:h,depth:d},scene);
        box.position = new BABYLON.Vector3(x,h/2,z);
        box.checkCollisions = true;
        box.isVisible = false;
    }
    wall(0,25,50,3,1);
    wall(0,-25,50,3,1);
    wall(25,0,1,3,50);
    wall(-25,0,1,3,50);

    // Cam√©ra
    const camera = new BABYLON.FollowCamera("cam", new BABYLON.Vector3(0,17,-20), scene);
    camera.lockedTarget = playerCollider;
    camera.radius = 20;
    camera.heightOffset = 17;
    camera.rotationOffset = 90;

    const combatContext = {
        prevPlayerPos: null,
        prevNpcPos: null,
        prevRadius: camera.radius,
        prevHeight: camera.heightOffset,
        prevRot: camera.rotationOffset
    };

    // ===== MENUS HTML =====
    function openMainMenu() {
        if (gameState.mode === "combat") return;
        console.log("üìã Ouverture menu principal");
        gameState.menuOpen = true;
        overlayEl.classList.add("visible");
        mainMenuEl.classList.add("open");
        inventoryMenuEl.classList.remove("open");
        teamMenuEl.classList.remove("open");
        inventoryDetailEl.classList.remove("show");
        gameState.selectedItemIndex = null;
    }

    function closeAllMenus() {
        console.log("‚ùå Fermeture menus");
        gameState.menuOpen = false;
        mainMenuEl.classList.remove("open");
        inventoryMenuEl.classList.remove("open");
        teamMenuEl.classList.remove("open");
        inventoryDetailEl.classList.remove("show");
        gameState.selectedItemIndex = null;
        if (!gameState.dialogOpen && gameState.mode !== "combat") {
            overlayEl.classList.remove("visible");
        }
    }

    function toggleMenu() {
        if (gameState.mode === "combat") return;
        if (gameState.menuOpen) closeAllMenus();
        else openMainMenu();
    }

    // ===== INVENTAIRE HTML =====
    function renderInventory() {
        inventoryGridEl.innerHTML = "";
        gameState.playerInventory.forEach((it, idx) => {
            const card = document.createElement("div");
            card.className = "inv-item";
            card.innerHTML = `
                <div class="inv-icon">${it.icon}</div>
                <div class="inv-name">${it.name}</div>
                <div class="inv-count">x${it.count}</div>
            `;
            card.addEventListener("click", () => openItemDetail(idx));
            inventoryGridEl.appendChild(card);
        });
    }

    function openItemDetail(index) {
        const it = gameState.playerInventory[index];
        if (!it) return;
        gameState.selectedItemIndex = index;
        inventoryDetailTitleEl.textContent = `${it.icon} ${it.name}`;
        inventoryDetailDescEl.textContent = it.description || "Aucune description.";
        inventoryDetailEl.classList.add("show");
    }

    btnUseItemEl.addEventListener("click", () => {
        const idx = gameState.selectedItemIndex;
        if (idx == null) return;
        const it = gameState.playerInventory[idx];
        if (!it) return;

        showDialog(`Tu utilises ${it.name} !`);
        it.count--;
        if (it.count <= 0) {
            gameState.playerInventory.splice(idx, 1);
            gameState.selectedItemIndex = null;
            inventoryDetailEl.classList.remove("show");
        }
        renderInventory();
    });

    btnInfoItemEl.addEventListener("click", () => {
        const idx = gameState.selectedItemIndex;
        if (idx == null) return;
        const it = gameState.playerInventory[idx];
        showDialog(`${it.icon} ${it.name} : ${it.description || "Objet myst√©rieux."}`);
    });

    btnBackItemEl.addEventListener("click", () => {
        inventoryDetailEl.classList.remove("show");
        gameState.selectedItemIndex = null;
    });

    btnInventoryBackEl.addEventListener("click", () => {
        openMainMenu();
    });

    // ===== √âQUIPE HTML =====
    function hpColor(pct) {
        if (pct > 0.5) return "linear-gradient(90deg,#28c728,#8be628)";
        if (pct > 0.2) return "linear-gradient(90deg,#e6c228,#f6e46b)";
        return "linear-gradient(90deg,#e62828,#f66b6b)";
    }

    function renderTeam() {
        teamListEl.innerHTML = "";
        gameState.team.forEach(pk => {
            const pct = pk.hp / pk.maxHp;
            const card = document.createElement("div");
            card.className = "team-card";
            card.innerHTML = `
                <div class="team-icon">${pk.icon}</div>
                <div class="team-main">
                    <div class="team-name">${pk.name}</div>
                    <div class="team-level">Niv. ${pk.level} ‚Äî ${pk.hp}/${pk.maxHp} PV</div>
                    <div class="team-hpbar-wrap">
                        <div class="team-hpbar" style="width:${pct*100}%;background:${hpColor(pct)};"></div>
                    </div>
                </div>
                <div class="team-extra">${pk.status}</div>
            `;
            teamListEl.appendChild(card);
        });
    }

    btnTeamBackEl.addEventListener("click", () => {
        openMainMenu();
    });

    // ===== BOUTONS MENU PRINCIPAL =====
    trainerNameEl.textContent = gameState.playerName;
    trainerMoneyEl.textContent = gameState.money + "‚ÇΩ";

    btnMenuInventory.addEventListener("click", () => openInventoryMenu());
    btnMenuTeam.addEventListener("click", () => openTeamMenu());
    btnMenuMap.addEventListener("click", () => showDialog("üó∫Ô∏è La carte n'est pas encore disponible."));
    btnMenuSave.addEventListener("click", () => showDialog("üíæ Partie sauvegard√©e !"));
    btnMenuOptions.addEventListener("click", () => showDialog("‚öôÔ∏è Options en d√©veloppement."));
    btnMenuClose.addEventListener("click", () => closeAllMenus());

    function openInventoryMenu() {
        mainMenuEl.classList.remove("open");
        inventoryMenuEl.classList.add("open");
        inventoryDetailEl.classList.remove("show");
        renderInventory();
    }

    function openTeamMenu() {
        mainMenuEl.classList.remove("open");
        teamMenuEl.classList.add("open");
        renderTeam();
    }

    // ===== INTERACTION =====
    function interact() {
        if (gameState.menuOpen || gameState.dialogOpen) return;
        if (gameState.mode === "combat") return;

        const pos = playerCollider.position;
        const distNpc = BABYLON.Vector3.Distance(pos, npc.position);

        if (distNpc < gameState.interactionRange) {
            // Lancer combat
            enterCombatFromWorld(playerCollider, npc, camera, combatContext);
            return;
        }

        if (item.isVisible && BABYLON.Vector3.Distance(pos, item.position) < gameState.interactionRange) {
            showDialog("Tu trouves une Hyper Potion !");
            item.isVisible = false;
            gameState.playerInventory.push({
                name:"Hyper Potion",
                count:1,
                icon:"üß™",
                description:"Restaure beaucoup de PV (50 PV)."
            });
            renderInventory();
        }
    }

    // ===== CLAVIER =====
    const inputMap = {};
    const keyJustPressed = {};

    scene.onKeyboardObservable.add(e => {
        const rawKey = e.event.key;
        const k = rawKey.toLowerCase();

        if (e.type === BABYLON.KeyboardEventTypes.KEYDOWN) {
            // MODE COMBAT : navigation dans interface de combat
            if (gameState.mode === "combat") {
                handleCombatKeyboard(rawKey, k, playerCollider, npc, camera, combatContext);
                return;
            }

            // MODE EXPLORATION
            if (!keyJustPressed[k]) {
                keyJustPressed[k] = true;
                inputMap[k] = true;

                if (k === "e") interact();
                if (k === "m") toggleMenu();
                if (rawKey === "Escape") closeAllMenus();
                if (rawKey === "Shift") gameState.isRunning = true;
            }
        }

        if (e.type === BABYLON.KeyboardEventTypes.KEYUP) {
            inputMap[k] = false;
            keyJustPressed[k] = false;
            if (rawKey === "Shift") gameState.isRunning = false;
        }
    });

    function handleCombatKeyboard(rawKey, k, playerCollider, npc, camera, combatContext) {
        // root or attacks
        if (!combatState.active) {
            // combat termin√© -> sortie si touche
            exitCombatToWorld(playerCollider, npc, camera, combatContext);
            return;
        }

        if (combatState.phase === "root") {
            if (["arrowup","z","w"].includes(k)) {
                combatState.rootIndex = (combatState.rootIndex + combatChoicesButtons.length - 1) % combatChoicesButtons.length;
                updateCombatRootSelection();
            } else if (["arrowdown","s"].includes(k)) {
                combatState.rootIndex = (combatState.rootIndex + 1) % combatChoicesButtons.length;
                updateCombatRootSelection();
            } else if (["arrowleft","q"].includes(k)) {
                if (combatState.rootIndex === 1) combatState.rootIndex = 0;
                updateCombatRootSelection();
            } else if (["arrowright","d"].includes(k)) {
                if (combatState.rootIndex === 0) combatState.rootIndex = 1;
                updateCombatRootSelection();
            } else if (rawKey === "Enter") {
                const btn = combatChoicesButtons[combatState.rootIndex];
                const action = btn.dataset.action;
                const result = handlePlayerRootChoice(action);
                if (result && result.finished) {
                    // Fin du combat
                    setTimeout(() => {
                        exitCombatToWorld(playerCollider, npc, camera, combatContext);
                    }, 500);
                }
            } else if (rawKey === "Escape") {
                const result = handlePlayerRootChoice("run");
                if (result && result.finished) {
                    setTimeout(() => {
                        exitCombatToWorld(playerCollider, npc, camera, combatContext);
                    }, 500);
                }
            }
        } else if (combatState.phase === "attacks") {
            // navigation 2x2
            let idx = combatState.attackIndex;
            if (["arrowup","z","w"].includes(k)) {
                idx = (idx - 2 + 4) % 4;
            } else if (["arrowdown","s"].includes(k)) {
                idx = (idx + 2) % 4;
            } else if (["arrowleft","q"].includes(k)) {
                if (idx % 2 === 1) idx--;
            } else if (["arrowright","d"].includes(k)) {
                if (idx % 2 === 0) idx++;
            } else if (rawKey === "Enter") {
                const result = handlePlayerAttackChoice(combatState.attackIndex);
                if (result && result.finished) {
                    setTimeout(() => {
                        exitCombatToWorld(playerCollider, npc, camera, combatContext);
                    }, 500);
                } else {
                    // retour au menu root apr√®s attaque
                    hideAttackMenu();
                    setCombatQuestion(`Que doit faire ${combat.player.name} ?`);
                    updateCombatRootSelection();
                }
            } else if (rawKey === "Escape") {
                hideAttackMenu();
                setCombatQuestion(`Que doit faire ${combat.player.name} ?`);
                updateCombatRootSelection();
            }
            combatState.attackIndex = idx;
            updateAttackSelection();
            updateAttackInfo();
        }
    }

    // ===== GAMEPAD =====
    const GP = {courir:0, interagir:1, menu:3};
    const pressed = {};
    let lastGPPress = {};

    new BABYLON.GamepadManager().onGamepadConnectedObservable.add(gp => {
        gamepad = gp;
        console.log("üéÆ Manette connect√©e:", gp.id);

        gp.onButtonDownObservable.add(btn => {
            const b = typeof btn === "number" ? btn : btn.index || btn;
            if (pressed[b]) return;
            pressed[b] = true;
            const now = Date.now();

            if (gameState.mode === "combat") {
                // simple : A = valider (courir), B = changer option (interagir)
                if (b === GP.interagir) {
                    // B -> simule "ArrowDown" pour root, ou next attack
                    handleCombatKeyboard("ArrowDown", "arrowdown", playerCollider, npc, camera, combatContext);
                } else if (b === GP.courir) {
                    // A -> Enter
                    handleCombatKeyboard("Enter", "enter", playerCollider, npc, camera, combatContext);
                }
                return;
            }

            if (b === GP.menu && (!lastGPPress.menu || now - lastGPPress.menu > 300)) {
                lastGPPress.menu = now;
                toggleMenu();
            }

            if (!gameState.menuOpen) {
                if (b === GP.interagir) interact();
                if (b === GP.courir) gameState.isRunning = true;
            }
        });

        gp.onButtonUpObservable.add(btn => {
            const b = typeof btn === "number" ? btn : btn.index || btn;
            pressed[b] = false;
            if (b === GP.courir) gameState.isRunning = false;
        });
    });

    // ===== MOUVEMENT =====
    scene.onBeforeRenderObservable.add(() => {
        hudSpeedTextEl.textContent = gameState.isRunning ? "üèÉ Course" : "üö∂ Marche";

        const distNpc = BABYLON.Vector3.Distance(playerCollider.position, npc.position);
        npcIcon.isVisible = (distNpc < gameState.interactionRange) && (gameState.mode !== "combat");

        if (gameState.menuOpen || gameState.dialogOpen || gameState.mode === "combat") return;

        const spd = gameState.isRunning ? 0.2 : 0.1;
        let dx = 0, dz = 0;

        if (inputMap["z"] || inputMap["w"]) dx -= spd;
        if (inputMap["s"]) dx += spd;
        if (inputMap["d"]) dz += spd;
        if (inputMap["a"] || inputMap["q"]) dz -= spd;

        if (gamepad) {
            const D = 0.15;
            const lx = Math.abs(gamepad.leftStick.x) > D ? gamepad.leftStick.x : 0;
            const ly = Math.abs(gamepad.leftStick.y) > D ? gamepad.leftStick.y : 0;
            dz += lx * spd;
            dx -= ly * spd;
        }

        if (dx || dz) player.rotation.y = Math.atan2(dz, dx);
        playerCollider.moveWithCollisions(new BABYLON.Vector3(dx, 0, dz));
    });

    console.log("‚úÖ Sc√®ne pr√™te !");
    return scene;
}

const scene = createScene();
engine.runRenderLoop(() => scene.render());
window.addEventListener("resize", () => engine.resize());

console.log("üéÆ Jeu d√©marr√© ! Approche le PNJ et appuie sur E pour lancer un combat.");
</script>
</body>
</html>
