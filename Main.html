<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>PokÃ©mon-like Game</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #renderCanvas { width: 100%; height: 100vh; touch-action: none; }
        #instructions {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0,0,0,0.8);
            color: white;
            padding: 15px;
            border-radius: 8px;
            font-size: 12px;
            line-height: 1.8;
            font-family: Arial, sans-serif;
        }
        #instructions strong { color: #FFD700; }
    </style>
</head>
<body>
    <canvas id="renderCanvas"></canvas>

    <div id="instructions">
        <strong>ðŸŽ® ContrÃ´les Clavier:</strong><br>
        ZQSD / FlÃ¨ches : DÃ©placer<br>
        Shift : Courir<br>
        E : Interagir<br>
        M : Menu<br>
        Ã‰chap : Fermer menu<br><br>
        <strong>ðŸŽ® ContrÃ´les Manette:</strong><br>
        Stick gauche : DÃ©placer<br>
        X : Courir<br>
        A : Interagir<br>
        Y : Menu
    </div>

    <!-- Babylon JS -->
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script src="https://cdn.babylonjs.com/gui/babylon.gui.min.js"></script>

<script>
const canvas = document.getElementById("renderCanvas");
const engine = new BABYLON.Engine(canvas, true);

let gamepad = null;

// Ã‰tat global
const gameState = {
    menuOpen: false,
    dialogOpen: false,
    isRunning: false,
    interactionRange: 3,
    playerInventory: ["Potion x3", "PokÃ© Ball x5", "Antidote x1"],
    playerName: "Red",
    money: 500
};

function createScene() {

    const scene = new BABYLON.Scene(engine);
    scene.collisionsEnabled = true;


    //----------------------------------------
    // â­ LUMIÃˆRE + SOL
    //----------------------------------------
    const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0,1,0), scene);

    const ground = BABYLON.MeshBuilder.CreateGround("ground", {width:50,height:50}, scene);
    const groundMat = new BABYLON.StandardMaterial("groundMat", scene);
    groundMat.diffuseColor = new BABYLON.Color3(0.3, 0.7, 0.3);
    ground.material = groundMat;


    //----------------------------------------
    // â­ PLAYER
    //----------------------------------------
    const player = BABYLON.MeshBuilder.CreateSphere("player", {diameter:1}, scene);
    player.position = new BABYLON.Vector3(0,0.5,0);
    const mat = new BABYLON.PBRMaterial("pmat", scene);
    mat.albedoColor = new BABYLON.Color3(1,0.4,0);
    player.material = mat;


    //----------------------------------------
    // â­ CAMERA 
    //----------------------------------------
    const camera = new BABYLON.FollowCamera("FollowCam", new BABYLON.Vector3(0,17,-20), scene);
    camera.lockedTarget = player;
    camera.radius = 20;
    camera.heightOffset = 17;
    camera.rotationOffset = 90;
    camera.cameraAcceleration = 0.05;
    camera.maxCameraSpeed = 10;



    //----------------------------------------
    // â­ GUI
    //----------------------------------------
    const ui = BABYLON.GUI.AdvancedDynamicTexture.CreateFullscreenUI("UI");

    const speedIndicator = new BABYLON.GUI.TextBlock();
    speedIndicator.text = "ðŸš¶ Marche";
    speedIndicator.color = "white";
    speedIndicator.fontSize = 18;
    speedIndicator.top = "10px";
    speedIndicator.left = "10px";
    speedIndicator.horizontalAlignment = BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_LEFT;
    speedIndicator.verticalAlignment = BABYLON.GUI.Control.VERTICAL_ALIGNMENT_TOP;
    ui.addControl(speedIndicator);



    //----------------------------------------
    // â­ SYSTEME CLAVIER â€” VERSION PRO (CORRIGÃ‰E)
    //----------------------------------------
    const inputMap = {};

    scene.onKeyboardObservable.add((kbInfo) => {
        const key = kbInfo.event.key.toLowerCase();

        switch (kbInfo.type) {

            // ---- KEY DOWN ----
            case BABYLON.KeyboardEventTypes.KEYDOWN:
                inputMap[key] = true;

                if (key === "e" && !gameState.menuOpen && !gameState.dialogOpen) {
                    // Interaction
                    const int = checkInteractions(player);
                    if (int) int();
                }

                if (key === "m") toggleMenu();

                if (kbInfo.event.key === "Escape") toggleMenu();

                if (kbInfo.event.key === "Shift") {
                    gameState.isRunning = true;
                    speedIndicator.text = "ðŸƒ Course";
                    speedIndicator.color = "yellow";
                }
            break;


            // ---- KEY UP ----
            case BABYLON.KeyboardEventTypes.KEYUP:
                inputMap[key] = false;

                if (kbInfo.event.key === "Shift") {
                    gameState.isRunning = false;
                    speedIndicator.text = "ðŸš¶ Marche";
                    speedIndicator.color = "white";
                }
            break;
        }
    });



    //----------------------------------------
    // â­ GAMEPAD MAPPING
    //----------------------------------------
    const gamepadManager = new BABYLON.GamepadManager();

    const GamepadMap = {
        interagir: 0, // A
        courir: 2,    // X
        menu: 3       // Y
    };

    let buttonPressed = {};


    gamepadManager.onGamepadConnectedObservable.add((gp)=>{
        console.log("Gamepad dÃ©tectÃ©:", gp.id);
        gamepad = gp;

        gp.onButtonDownObservable.add((button)=>{
            if (buttonPressed[button]) return;
            buttonPressed[button] = true;

            if (button === GamepadMap.menu) toggleMenu();

            if (button === GamepadMap.interagir && !gameState.menuOpen && !gameState.dialogOpen) {
                const int = checkInteractions(player);
                if (int) int();
            }

            if (button === GamepadMap.courir) {
                gameState.isRunning = true;
                speedIndicator.text = "ðŸƒ Course";
                speedIndicator.color = "yellow";
            }
        });

        gp.onButtonUpObservable.add((button)=>{
            buttonPressed[button] = false;

            if (button === GamepadMap.courir) {
                gameState.isRunning = false;
                speedIndicator.text = "ðŸš¶ Marche";
                speedIndicator.color = "white";
            }
        });
    });



    //----------------------------------------
    // â­ DEPLACEMENT JOUEUR
    //----------------------------------------
    scene.onBeforeRenderObservable.add(()=>{

        if (gameState.menuOpen || gameState.dialogOpen) return;

        const speed = gameState.isRunning ? 0.2 : 0.1;

        // --- CLAVIER ---
        if (inputMap["d"]) player.position.z += speed;
        if (inputMap["a"] || inputMap["q"]) player.position.z -= speed;
        if (inputMap["z"] || inputMap["w"]) player.position.x -= speed;
        if (inputMap["s"]) player.position.x += speed;

        // --- GAMEPAD ---
        if (gamepad) {
            player.position.x += gamepad.leftStick.x * speed * 2;
            player.position.z += gamepad.leftStick.y * speed * 2;
        }

        // Check interactions real-time
        checkInteractions(player);
    });


    //----------------------------------------
    // â­ INTERACTIONS (simplifiÃ© pour stabilitÃ©)
    //----------------------------------------
    function checkInteractions(player) {
        return null; // tu pourras remettre ton systÃ¨me ici sans changer la logique clavier
    }

    //----------------------------------------
    // â­ MENU
    //----------------------------------------
    function toggleMenu() {
        gameState.menuOpen = !gameState.menuOpen;
    }


    return scene;
}

const scene = createScene();

engine.runRenderLoop(()=>{
    scene.render();
});

window.addEventListener("resize", ()=>{
    engine.resize();
});
</script>
</body>
</html>
